__author__ = 'Jeddah'
__project__ = "WaterDemandMdeol"


import sampling_db as DB
import C_ApplianceType as Appliance
import C_UnitType as Unit
import C_ResidentialUnit as residential
import C_CommercialUnit as commercial


class WaterDemandModel():
    """

    """

    __residential_units = []          # the number of residential units represented by an array. Where the integer at each index represent the number of actors in the unit. i.e. [3,4] = 2 units of 3 and 4 res actors respectively
    __commercial_units = []           # the number of commercial units represented by an array. Where the integer at each index represent the number of actors in the unit. i.e. [10,15] = 2 units of 10 and 15 res actors respectively

    __timeseries = {}     # is the dictionary initialised at the start of each day to store the volumes of water generated by each appliance at an hourly timestep. As well as the number of actors in the building
    __demand_output = {}

    def resetDay(self):
        """
        resets __timeseries dictionary back to blank values each time the method is called.
        So that volumes produced in day 1 are not carried over to day 2 etc.
        """

        self.__initialiseTimeseries()

    def __init__(self,residential_units,commercial_units):

        # to stop run time error if zero's are provided as input:
        if len(residential_units)== 1:
            if residential_units[0] == 0:
                self.__commercial_units = []

        if len(commercial_units) == 1:
            if commercial_units[0] == 0:
                self.__residential_units = []

        # initialise objects:
        self.__residential_units = residential_units
        self.__commercial_units = commercial_units
        self.__demand_output = {}

    def __initialiseTimeseries(self):
        """
        This method initialises a timeseries array for each event and places it within the dictionary called 'timeseries'. The key of the dictionary is the unit_type (from C_Unit_TYpe) e.g. "COMMERCIAL" and appliance_type (from C_Appliances()) e.g. 'toilet'.
        For each appliance key an array of zeros is initialised. Where each zero represents one timestep of the timeseries. Volumes generated at different time steps can then be used to populate the initialised timeseries array.
        The size of the array is dependant on the input 'elements'. Arrays for each appliance are made for all of the unit_types.

        A key for the number of actors ("actors") is also initialised in this method

        :return: an initialised dictionary {RESIDENTIAL:{event_type1:[0,0,0,0,0....n(elements)],event_type2: [0,0,0,0,0,0,....n(elements)],actors: 0.0}
        """

        for u_type in Unit.unit_types:                 # for each of the unit types (e.g. residential, commercial etc.)

            self.__timeseries[u_type] = {}                        # make a nested dictionary (e.g. timeseries = {'commercial': {} :, 'residential' :{}, }
            self.__timeseries[u_type]["actors"]= 0.0              # create a key for the number of actors. Initialise it with a zero

            # appliances used depend on unit type, therefore grab the correct appliance list:

            if u_type == "RESIDENTIAL":
                appliances = Appliance.residential_appliance_types
            elif u_type == "COMMERCIAL":
                appliances = Appliance.commercial_appliance_types
            else:
                print "error: the unit type does not exist"

            # create an array of zero's for each appliance in the unit:

            for a_type in appliances:       # for all of the appliance types e.g. toilet, shower, etc.
                array = []                                  # make a empty array
                for i in range(24):               # for each step in the timeseries of 24hrs:
                    array.append(0.0)                            # add a zero to a
                self.__timeseries[u_type][a_type] = array               # append it to the relevant array in the dictionary specified by unit type and appliance type.


    def __createTimeSeries(self,events,unit_type,numberOfActors):
        """
        This method is used to create a timeseries of water use volumes for each end use (event_type) within each unit type.
        It does this by extracting the relevant information (volume, time) from the event objects generated by the relevant unit class
        For each event_type a different array of water use volumes (at each hour of the day) is generated.
        This information is stored in the form of a dictionary.

        The method also adds the number of actors within the unit - based on inputs to the method

        :param events: All the water use event objects from each appliance
        :param unit_type: i.e. Comm or Res. Required for the dictionary key to attach the relevant number of actors
        :param numberOfActors: number of actors (people) within the unit being modelled

        :return: A filled in dictionary containing the water use volumes at each hour of the day for each appliances and the number of actors within
                 the unit.
        """

        self.__initialiseTimeseries()                                   # sets __timeseries back to zero's again. Otherwise volumes from one unit get added to the next.

        self.__timeseries[unit_type]["actors"] = numberOfActors         # get the number of actors

        for e in events:                            # for all of the water events generated by a household:
            u_type = e.getUnitType()                # get the unit type of the event (i.e is the event occurring in a residential unit or commercial unit)

            # For individual event types:
            volumes = self.__timeseries[u_type][e.getAppliance()]    # From the dictionary, get the initialised array for the specific event_type.
                                                                     # Each time it goes through the loop, it calls up the correct array (corresponding to the key),
                                                                     # and adds the volume to it that is generated at a specific time using the code below.
            start = e.getStartTime()                    # get the start time of the event
            volume = e.getVolume()                      # get the volume of the event
            volumes[int(start)] += volume               # Add the volume generated to the relevant timestep of the volumes array (who's index is the same as that of the start time)


    def generateResidentialDemands(self):
        """
        Method is used to call all relevant methods of the residential classes to generate water use volumes a day.
        :return: A timeseries dictionary at an hourly timestep with volumes produced for each appliance. As well as the
        number of actors in the residential building.
        """

        res_name_counter = 1  # used to create a name for each unit e.g. R1, R2
        res_actor_counter = 0  # represents the index of the res_unit array --> so the relevant number of people can be returned

        for i in range(len(self.__residential_units)):  # for the number of res units specified:


            # create a res unit ID R1 --> Rn
            res_name = "R" + str(res_name_counter)
            self.__demand_output[res_name] = {}

            res_name_counter += 1

            # get the number of actors in the unit from the input vector:
            number_of_residential_actors = self.__residential_units[res_actor_counter]

            res_actor_counter += 1

            r = residential.ResidentialUnit(number_of_residential_actors)  # instantiate the Residential Unit Class (with the number of actors)

            all_resident_unit_events = r.getAllUnitEvents()  # get all of the residential unit events

            self.__createTimeSeries(all_resident_unit_events, "RESIDENTIAL", number_of_residential_actors)  # populate the empty dictionary with volumes for each appliance. Append the number of actors.

            self.__demand_output[res_name] = self.__timeseries["RESIDENTIAL"]  # append the populated dictionary to the output dictionary. Only return Residential information. Otherwise an empty dictionary for Commercial is returned as well.


    def generateCommercialDemands(self):
        """
        Method is used to call all relevant methods of the commercial classes to generate water use volumes a day.
        :return: A timeseries dictionary at an hourly timestep with volumes produced for each appliance. As well as the
        number of actors in the residential building.
        :return:
        """

        com_name_counter = 1  # used to create a name for each unit e.g. C1, C2
        com_actor_counter = 0  # represents the index of the res_unit array --> so the relevant number of people can be returned

        for j in range(len(self.__commercial_units)):  # for the number of commercial units specified:

            # create a res unit ID C1 --> Cn
            comm_name = "C" + str(com_name_counter)
            self.__demand_output[comm_name] = {}
            com_name_counter += 1

            # get the number of actors in the unit from the input vector:
            number_of_commercial_actors = self.__commercial_units[com_actor_counter]
            com_actor_counter += 1

            c = commercial.CommercialUnit(
                number_of_commercial_actors)  # instantiate the Commercial Unit Class (with the number of actors)

            all_commercial_unit_events = c.getAllUnitEvents()  # get all of the commercial unit events

            self.__createTimeSeries(all_commercial_unit_events, "COMMERCIAL",number_of_commercial_actors)  # populate the empty dictionary with volumes for each appliance. Append the number of actors.

            self.__demand_output[comm_name] = self.__timeseries["COMMERCIAL"]  # append the populated dictionary to the output dictionary. Only return Commercial information. Otherwise an empty dictionary for Residential is returned as well.

    def newDay(self):
        """
        calls methods that generate water demands
        """

        self.resetDay()         # resets __timeseries array to have zero's

        self.generateResidentialDemands()

        self.generateCommercialDemands()

    def getDemands(self):
        """
        returns demand_output dictionary produced through methods in run
        """

        return self.__demand_output

if __name__ == "__main__":

    res_units = [3,2]
    com_units = []

    wb = WaterDemandModel(res_units,com_units)
    day = 1
    for i in range(2):
        wb.newDay()
        print "day ", day

        print "R1 toilet: ", wb.getDemands()["R1"]["toilet"]
        # print "R1 actors ", wb.getDemands()["R1"]["actors"]
        print "R2 toilet ", wb.getDemands()["R2"]["toilet"]
        # print "R2 actors ", wb.getDemands()["R2"]["actors"]
        day += 1






