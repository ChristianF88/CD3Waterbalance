__author__ = 'Jeddah'
__project__ = 'WaterDemandModel'


import sampling_db as DB
import calcAndSampleCumData as SC
import C_ResidentialUnit as residential
import C_CommercialUnit as commercial
import C_UnitType as UT
import C_ApplianceType as Appliance
import csv

"""
The main interface is used to provide a platform to run the WaterDemandModel. Its purpose is to:

- generate a empty vector representing a timeseries of the hours in the day for each water appliance in each unit type
- grab the relevant event data (event volume and time) from each appliance, and append it to the timeseries vector at the relevant timestep
- generate demand outputs for multiple units
"""


def initialiseTimeseries(elements):
    """
    This method initialises a timeseries array for each event and places it within the dictionary called 'timeseries'. The key of the dictionary is the unit_type (from C_Unit_TYpe) e.g. "COMMERCIAL" and appliance_type (from C_Appliances()) e.g. 'toilet'.
    For each appliance key an array of zeros is initialised. Where each zero represents one timestep of the timeseries. Volumes generated at different time steps can then be used to populate the initialised timeseries array.
    The size of the array is dependant on the input 'elements'. Arrays for each appliance are made for all of the unit_types.

    A key for the number of actors ("actors") is also initialised in this method

    :param elements: The number of steps in the timeseries. i.e. If you want to represent each hour of one day, elements would = 24
    :return: an initialised dictionary {RESIDENTIAL:{event_type1:[0,0,0,0,0....n(elements)],event_type2: [0,0,0,0,0,0,....n(elements)],actors: 0.0}
    """

    timeseries = {}                              # create a dictionary

    for u_type in UT.unit_types:                 # for each of the unit types (e.g. residential, commercial etc.)

        timeseries[u_type] = {}                        # make a nested dictionary (e.g. timeseries = {'commercial': {} :, 'residential' :{}, }
        timeseries[u_type]["actors"]= 0.0              # create a key for the number of actors. Initialise it with a zero

        # appliances used depend on unit type, therefore grap the correct appliance list:

        if u_type == "RESIDENTIAL":
            appliances = Appliance.residential_appliance_types
        elif u_type == "COMMERCIAL":
            appliances = Appliance.commercial_appliance_types
        else:
            print "error: appliance '",u_type,"' does not exist"

        # create an array of zero's for each appliance in the unit:

        for a_type in appliances:       # for all of the appliance types e.g. toilet, shower, etc.
            array = []                                  # make a empty array
            for i in range(elements):               # for each step in the timeseries:
                array.append(0.0)                            # add a zero to a
            timeseries[u_type][a_type] = array               # append it to the relevant array in the dictionary specified by unit type and appliance type.

    return timeseries

def createTimeSeries(events,time_series,unit_type,numberOfActors):
    """
    This method is used to create a timeseries of water use volumes for each end use (event_type) within each unit type.
    It does this by extracting the relevant information (volume, time) from the event objects generated by the relevant unit class
    For each event_type a different array of water use volumes (at each hour of the day) is generated.
    This information is stored in the form of a dictionary.

    The method also adds the number of actors within the unit - based on inputs to the method

    :param events: All the water use events from each appliance
    :param time_series: initialised timeseries dictionary produced in def init_timeseries
    :param unit_type: i.e. Comm or Res. Required for the dictionary key to attach the relevant number of actors
    :param numberOfActors: number of actors (people) within the unit being modelled

    :return: A filled in dictionary containing the water use volumes at each hour of the day for each appliances and the number of actors within
             the unit.
    """

    time_series[unit_type]["actors"] = numberOfActors

    for e in events:                            # for all of the water events generated by a household:
        u_type = e.getUnitType()                # get the unit type of the event (i.e is the event occurring in a residential unit or commercial unit)

        # For individual event types:
        volumes = time_series[u_type][e.getAppliance()]    # From the dictionary, get the initialised array for the specific event_type.
                                                        # Each time it goes through the loop, it calls up the correct array (corresponding to the key),
                                                        # and adds the volume to it that is generated at a specific time using the code below.
        start = e.getStartTime()                    # get the start time of the event
        volume = e.getVolume()                      # get the volume of the event
        volumes[int(start)] += volume               # Add the volume generated to the relevant timestep of the volumes array (who's index is the same as that of the start time)

def run(res_units,comm_units):
    """
    This is method is used to call all relevant methods within the WaterDemandModel code. It creates water demand
    timeseries for a specified number of commercial and residential units.

    :param res_units: the number of residential units to be modelled
    :param comm_units: the number of commercial units to be modelled
    :return:
    """

    output = {}             # create empty dictionary

    "RESIDENTIAL EVENTS"

    res_actors_input_dist = DB.SamplingDatabase.Instance().getDBTest("RESIDENTIAL","RESIDENTIAL_UNIT_SIZE_DATABASE")        # input distribution where the number of res. actors is sampled from for each unit

    for i in range(res_units):              # for the number of res units specified:

        # create a res unit ID R1 --> Rn
        res_name = "R" + str(i+1)
        output[res_name] = {}

        number_of_residential_actors = SC.getSampledCumValue(res_actors_input_dist)     # sample from the input distribution

        r = residential.ResidentialUnit(number_of_residential_actors)                   # instantiate the Residential Unit Class (with the number of actors)

        all_resident_unit_events = r.getAllUnitEvents()                                 # get all of the residential unit events

        res_volumes_array = initialiseTimeseries(24)                                    # initialise a empty dictionary to store the generated water volumes

        createTimeSeries(all_resident_unit_events,res_volumes_array,"RESIDENTIAL",number_of_residential_actors)      # populate the empty dictionary with volumes for each appliance. Append the number of actors.

        output[res_name] = res_volumes_array["RESIDENTIAL"]                             # append the populated dictionary to the output dictionary. Only return Residential information. Otherwise an empty dictionary for Commercial is returned as well.

    "COMMERCIAL EVENTS"

    number_of_commercial_actors =4                                        # dummy data

    for j in range(comm_units):                                           # for the number of commercial units specified:

        # create a res unit ID C1 --> Cn
        comm_name = "C" + str(j+1)
        output[comm_name] = {}

        c = commercial.CommercialUnit(number_of_commercial_actors)      # instantiate the Commercial Unit Class (with the number of actors)

        all_commercial_unit_events = c.getAllUnitEvents()               # get all of the commercial unit events

        comm_volumes_array = initialiseTimeseries(24)                   # initialise a empty dictionary to store the generated water volumes

        createTimeSeries(all_commercial_unit_events,comm_volumes_array,"COMMERCIAL",number_of_commercial_actors)        # populate the empty dictionary with volumes for each appliance. Append the number of actors.

        output[comm_name] = comm_volumes_array["COMMERCIAL"]            # append the populated dictionary to the output dictionary. Only return Commercial information. Otherwise an empty dictionary for Residential is returned as well.


    "WRITE TO CSV FILE"

    # writes the output dictionary to a csv file labelled 'output'

    writer = csv.writer(open('output.csv','wb'))        # create a csv file with no blank spaces (wb) - stops blank rows occuring between each row of data

    for key,value in output.items():                    # for each of the keys (R1, R2, C1, C2 etc) in the output dictionary:
         writer.writerow([key,value])                         # write the relevant data to a row in the csv file. i.e. one row per unit.

    return output

















