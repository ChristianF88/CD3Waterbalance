__author__ = 'JBreman'
__project__ = 'WaterDemandModel'


import numpy as np
import math as math
import sampling_db as DB
import calcAndSampleCumData as CD
import sampleDataBin as SB
import sampleDiurnalPattern as DP
import C_Taps as TP
import C_WashMachine as WM
import C_Dishwasher as DW


# unit objects:
unit_types = ["RESIDENTIAL","COMMERCIAL"]                      # array of unit types.


# Dishwasher objects manipulated by class:
__dish_washer_freq = 0             # number of times dishwasher is used each day
__dish_washes = []                 # array of number of washes e.g. [1,] if freq = 2
__dishWashEvents = []              # used to store the dish wash event objects (with time and volume data)

# Washing machine objects manipulated by class:
__wash_machine_freq = 0             # number of times wash machine is used each day
__clothes_washes = []               # array of number of washes e.g. [1,1] if freq = 2
__washEvents = []                   # used to store the wash event objects (with time and volume)

# Tap objects manipulated by class:
__tap_volume = 0                   # represents the total volume of water generated by one actor through their tap use during one day.
__tap_use_duration = 0             # represents the length of one tap event (minutes)
__tapEvents = []                   # Stores each tap event that occurs at a certain time. The event is an object which contains data on the time the actor used tap, the duration of the event, the flowrate/volume of the event

class UnitType(object):
    """
    parent class of all units e.g. residential unit, commercial unit.
    """

    __unit = ''


    def __init__(self,building):

        self.__unit_type = building             # i.e. commercial or residential
        self.__wash_machine_freq = 0            # number of times per day the wash machine is used e.g. 1 or 1.5
        self.__clothes_washes = []              # empty array to store the number of clothes washes in a day
        self.__washEvents = []                  # empty array to store the washEvent objects with relevant data on time, volume, unit type
        self.__dish_washer_freq = 0             # number of times per day the dishwasher is used
        self.__dish_washes = []                 # empty array to store the number of dishwashes per day
        self.__dishWashEvents = []              # empty array to store the dishWashEvent obejects with relevant data
        self.__tap_volume = 0                   # the total tap volume used by a unit during a day
        self.__tap_use_duration = 0             # the length of time a tap is turned on for one event
        self.__tapEvents = []                   # a empty array to store all the tapEvent objects

        # initialised relevant methods:
        self.calcWashMachineFreq(self.__wash_machine_freq)
        self.calcWashingMachineUses()
        self.calcDishWasherFreq(self.__dish_washer_freq)
        self.calcDishWasherUses()
        self.calcTapUseVolume(self.__tap_volume)
        self.calcTapUseDuration()
        self.newDay()

    def calcWashMachineFreq(self,wash_freq):
        """
        Is the frequency of washes a unit does per day. This variable is determined seperatly in each child class as it will it will differ between building types. The child
        class calLs this method using "super" but with the updated variable of 'wash_freq'
        """

        self.__wash_machine_freq = wash_freq

    def calcWashingMachineUses(self):
        """
        This method makes an array which represents the number of times a unit washes clothes in a day. It uses the self.wash_machine_freq as an input.
        It works by:
            For example if wash_freq = 4.7.
            The method creates an array (wash_events), with four 1's ([1,1,1,1]. It then sees if the actor would wash another load
            based on the probability of 0.7 (4.7-4).

        Output: an array of 1's, representing each wash in a day.
        """
        yes = 1
        rand = np.random.sample()

         #if unit uses the washing machine less than once per day (i.e. freq <1):
        if self.__wash_machine_freq <1:

            if rand < self.__wash_machine_freq:

                self.__clothes_washes.append(yes)

        # if the unit uses washing machine once or more per day:
        elif self.__wash_machine_freq >= 1:

            washes = int(math.floor(self.__wash_machine_freq))

            for i in range(washes):

                self.__clothes_washes.append(yes)

            if rand < self.__wash_machine_freq - washes:

                self.__clothes_washes.append(yes)

    def calcDishWasherFreq(self,dish_wash_freq):
        """
        Is the frequency of dish washes a unit does per day. This variable is determined separately in each child class as it will it will differ between building types. The child
        class calLs this method using "super" but with the updated variable of 'dish_wash_freq'
        """

        self.__dish_washer_freq = dish_wash_freq

    def calcDishWasherUses(self):
        """
        This method makes an array which represents the number of times a unit uses the dishwasher in a day. It uses the self.dish_washer_freq as an input.
        It works by:
            For example if dish_wash_freq = 4.7.
            The method creates an array (wash_events), with four 1's ([1,1,1,1]. It then sees if the unit would wash another load
            based on the probability of 0.7 (4.7-4).

        Output: an array of 1's, representing each wash in a day.
        """
        yes = 1
        rand = np.random.sample()

        # if unit uses dish washer less than once per day (i.e. freq <1):
        if self.__dish_washer_freq <1:
            if rand < self.__dish_washer_freq:

                self.__dish_washes.append(yes)

        # if unit uses dish washer once or more per day:
        elif self.__dish_washer_freq >= 1:

            washes = int(math.floor(self.__dish_washer_freq))

            for i in range(washes):

                self.__dish_washes.append(yes)

            if rand < self.__dish_washer_freq - washes:

                self.__dish_washes.append(yes)

    def calcTapUseVolume(self,volume):
        """
        Is the volume of tap water a unit uses per day. This variable is determined seperatly in each child class as it will it will differ between building types. The child
        class calLs this method using "super" but with the updated variable of 'volume'
        """

        self.__tap_volume = volume


    def calcTapUseDuration(self):
        """
        input: requires a input distribution of relative frequencies for different tap use durations (minutes)
        :return: the length of time of one tap even for a actor.
        """
        self.__tap_use_duration = CD.getSampledCumValue(DB.SamplingDatabase.Instance().getDB("TAP_USE_DURATION_DATABASE"))

        if type(self.__tap_use_duration) == str:

            self.__tap_use_duration = SB.sampleDataBin(self.__tap_use_duration)


    def newDay(self):
        """
        Generates objects for each water event generated by a unit in a day. Objects contain relevant information on: the unit type where it was generated, the volume of the event
        and the time the event took place.
        """

        "Wash machine Events:"
        for i in range(len(self.__clothes_washes)):                         # For each wash:
            wash_time = DP.sampleCumDF(DB.SamplingDatabase.Instance().getDBTest(self.__unit_type,"DIURNAL_PATTERN"))          # Get the time that the wash cycle starts

            wash_event = WM.WashMachine(wash_time,self.__unit_type)              # Make an event object for each wash. This event contains info on the time and volume of the wash event

            self.__washEvents.append(wash_event)                                 # add each event to an array.

        "Dish washer Events:"

        for i in range(len(self.__dish_washes)):
            wash_time = DP.sampleCumDF(DB.SamplingDatabase.Instance().getDBTest(self.__unit_type,"DIURNAL_PATTERN"))

            wash_event = DW.DishWasher(wash_time,self.__unit_type)

            self.__dishWashEvents.append(wash_event)

        "Tap Events:"
        tot_volume = 0

        while tot_volume < self.__tap_volume:
            tap_use_time = DP.sampleCumDF(DB.SamplingDatabase.Instance().getDBTest(self.__unit_type,"DIURNAL_PATTERN"))

            tap_event = TP.Taps(tap_use_time,self.__tap_use_duration,self.__unit_type)

            self.__tapEvents.append(tap_event)

            tot_volume += tap_event.getVolume()


    def getWashEvents(self):

        return self.__washEvents

    def getDishWashEvents(self):

        return self.__dishWashEvents

    def getTapEvents(self):

        return self.__tapEvents

    def getAllUnitEvents(self):
        pass






